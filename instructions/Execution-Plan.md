Execution Plan (Local MVP: US Stocks → Groups → Fetch → Analyze → Visualize)
1) Repo & Tooling Setup

Create a mono-repo with two apps:

server/ (Node.js + TypeScript + Express)

client/ (React + TypeScript + Vite)

Add shared types package:

packages/shared/ for DTOs and common types (symbols, bars, metrics, signals).

Add basic scripts:

dev (runs server+client), lint, test, db:migrate, db:seed.

Deliverable: project boots locally, “Hello” endpoint + UI page.

2) Database & Data Model

Use SQLite with Prisma (or Drizzle).

Implement tables:

tickers, groups, group_members

price_bars_daily

analysis_runs, analysis_results

Seed initial content:

A few sample groups: MegaCap Tech, Semis, Energy, My Watchlist.

Deliverable: db:migrate and db:seed work; you can list groups via API.

3) Data Provider Layer (Pluggable)

Create MarketDataProvider interface:

getDailyBars(symbol, start, end)

getQuote(symbol) (optional MVP)

getMetadata(symbol) (optional MVP)

Implement Provider #1 (free source) as the default provider.

Add local caching:

On fetch, store daily bars in price_bars_daily.

When requested again, only fetch missing dates (gap detection).

Add robust error handling:

Rate limit backoff, retries (small), and “partial data” warnings.

Deliverable: API endpoint fetches & stores bars for a symbol and date range.

4) Core Analytics (MVP Metrics)

Implement pure functions under server/src/analytics/:

Returns: metrics + short explanation + optional signals

Metrics:

Returns: 1D, 5D, 1M, 3M

Volatility (annualized)

Max drawdown

SMA20, SMA50

RSI14

Volume Z-score (optional if volume available)

Signals:

RSI overbought/oversold flags

SMA20/50 cross

Simple breakout vs last 20-day high

Deliverable: unit tests for analytics on a small fixture dataset.

5) Group Insights (Cross-Sectional)

For a given group + date range:

Compute:

Group average return + dispersion (std dev)

Top/bottom performers

Outliers: >2σ from group return distribution

(Optional) correlation matrix if not too heavy

Output a “summary” object the UI can render:

headline bullets + ranked tables + chart-ready series.

Deliverable: POST /api/analyze works for a group and returns structured insights.

6) API Design & Contract

Implement endpoints:

GET /api/groups (list)

POST /api/groups (create manual group)

PUT /api/groups/:id/members (replace members)

POST /api/fetch (on-demand fetch/cached)

POST /api/analyze (symbols or groupId + range + metric set)

GET /api/runs/:id and GET /api/runs/:id/results

Define strict DTOs in packages/shared and validate inputs (zod).

Deliverable: stable JSON contract + request validation + meaningful error messages.

7) Frontend UI (MVP Screens)

Build 3 screens:

A) Groups

List groups

Create/edit manual group (comma-separated symbols)

“Analyze” button per group

B) Analyze Wizard

Choose: group or custom symbols

Choose range (preset: 6M, 1Y, YTD + custom)

Run analysis

C) Results Dashboard

Table: Symbol | 1M Return | Vol | RSI | Signal badges

Charts:

Bar: returns by symbol (sortable)

Scatter: return vs volatility

Line: price series for selected symbol with SMA overlays

“Data status”: last updated + provider used + missing data warnings

Deliverable: end-to-end flow usable from browser.

8) Observability & “Trust” Features

Add run metadata:

provider name, fetch timestamps, missing coverage

Add “Explain this” per metric/signal:

short tooltip text generated by server (not LLM needed).

Deliverable: user can see exactly what data was used and when.

9) Packaging & Local Run Experience

Single command local run:

yarn dev (or npm run dev)

Add .env.example

Add README with:

prerequisites, setup, run, seed, example workflows

Add export option:

download analysis results as JSON/CSV

Deliverable: clean local onboarding + reproducible results.

10) Stretch Goals (After MVP)

Add sector/industry enrichment (if free metadata available)

Add clustering by behavior:

correlation-based clustering, volatility regimes

Add scheduled refresh (node-cron)

Add alerts (local notifications or email later)

Suggested Milestones (Order of Work)

Skeleton + DB schema + seed

Provider + caching for daily bars

Analytics metrics + tests

Analyze endpoint + persisted runs/results

UI: groups → analyze → dashboard

Polish: error handling, data status, exports
